#!/usr/bin/env python3

import os
import sys
import ueberzug.lib.v0 as ueberzug
import array, fcntl, termios
import select
from image_size import get_image_size
import argparse
import types
from pathlib import Path

config_path = os.path.join(str(Path.home()), '.config/cimage/config')
if not os.path.exists(config_path):
    config_path = os.path.join(os.path.dirname(__file__), 'config')
config = types.ModuleType('config', 'Config')
with open(config_path) as f:
    code = compile(f.read(), "config", "exec")
    exec(code, config.__dict__)

parser = argparse.ArgumentParser(description='Python Command Line Image Viewer')
parser.add_argument('--input', type=str, help='Input Image.', required=True)
parser.add_argument('--verbose', dest='verbose', action='store_true')
parser.set_defaults(verbose=False)
args = parser.parse_args()

if args.verbose:
    print(f"Read config file: {config_path}")

def exception_handler(exception_type, exception, traceback, debug_hook=sys.excepthook):
    if args.verbose:
        debug_hook(exception_type, exception, traceback)
    else:
        print(f'{exception_type.__name__}: {exception}')

sys.excepthook = exception_handler

# https://stackoverflow.com/a/31736883
class KeyPoller():
    def __enter__(self):
        self.fd = sys.stdin.fileno()
        self.new_term = termios.tcgetattr(self.fd)
        self.old_term = termios.tcgetattr(self.fd)

        self.new_term[3] = (self.new_term[3] & ~termios.ICANON & ~termios.ECHO)
        termios.tcsetattr(self.fd, termios.TCSAFLUSH, self.new_term)

        return self

    def __exit__(self, type, value, traceback):
        termios.tcsetattr(self.fd, termios.TCSAFLUSH, self.old_term)

    def poll(self):
        dr,dw,de = select.select([sys.stdin], [], [], 0.0)
        if not dr == []:
            return sys.stdin.read(1)
        return None


@ueberzug.Canvas()
def main(canvas):
    try:
        image_width, image_height = get_image_size.get_image_size(args.input)
    except get_image_size.UnknownImageFormat:
        raise ValueError("Unknown Image Format")

    rows, columns = map(int, os.popen('stty size', 'r').read().split())
    buf = array.array('H', [0, 0, 0, 0])
    fcntl.ioctl(1, termios.TIOCGWINSZ, buf)
    terminal_width, terminal_height = buf[2], buf[3]
    scale = min(terminal_width/image_width, terminal_height/image_height)
    image_width *= scale
    image_height *= scale

    vertical_pixel_ratio = rows/terminal_height
    horizontal_pixel_ratio = columns/terminal_width

    canvas_height = rows

    if image_width > terminal_width:
        canvas_width = columns
        x, y = 0, 0
    else:
        x = int((terminal_width - image_width)/2 * horizontal_pixel_ratio)
        y = int((terminal_height - image_height)/2 * vertical_pixel_ratio)

        canvas_width = columns
        image = canvas.create_placement('image', x=x, y=y,
                width=canvas_width,
                height = rows-y,
                scaler=ueberzug.ScalerOption.FIT_CONTAIN.value)
        image.path = args.input
        image.visibility = ueberzug.Visibility.VISIBLE

        with KeyPoller() as keyPoller:
            while True:
                key = keyPoller.poll()
                rows, columns = map(int, os.popen('stty size', 'r').read().split())
                image.width = columns
                image.height = rows - y
                if key is not None:
                    if key == config.KeyBindings.move_image_down:
                        image.y += 1
                    elif key == config.KeyBindings.move_image_up:
                        image.y -= 1
                    elif key == config.KeyBindings.move_image_left:
                        image.x -= 1
                    elif key == config.KeyBindings.move_image_right:
                        image.x += 1
                    elif key == config.KeyBindings.quit_program or ord(key) == 27:
                        break


if __name__ == '__main__':
    main()

